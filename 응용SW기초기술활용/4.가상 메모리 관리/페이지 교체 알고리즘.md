새로 적재될 페이지를 위한 주기억장치 공간을 확보하기 위하여, 현재 주기억장치를 차지하고 있는 페이지들 중에서 어떤 페이지를 선택하여 가상공간으로 보낼 것인가를 결정함

1. **FIFO(First-In First-Out) 알고리즘**
    - 가장 먼저 주기억장치에 적재되어진 페이지를 교체시키는 방법
    ![[pg.150 그림 4-17 FIFO 알고리즘.png]]
    - **페이지 부재** : 15회
    - **페이지 교체** : 12회
    **FIFO 모순(anomaly) 또는 Belady의 이변** : 프로세스에 할당된 페이지 프레임의 수가 증가했는데 페이지 부재가 더 증가하는 현상
    ![[pg.150 그림 4-18 FIFO 모순의 예.png]]
2. **최적 교체(Optimal Replacement) 알고리즘**
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체
    - 최소의 페이지 부재율을 갖는 알고리즘
    - 페이지 호출 순서에 대한 모든 상황을 사전에 미리 파악하고 있어야 하기 때문에 구현하기가 어렵고 비현실적
    ![[pg.152 그림 4-19 최적 교체 알고리즘.png]]
    - **페이지 부재** : 9회
    - **페이지 교환** : 6회
3. **LRU(Least Recently Used) 알고리즘**
    - 각 페이지마다 카운터나 스택을 두어 현시점에서 가장 오래전에 사용된 페이지를 교체하는 방법
    ![[pg.152 그림 4-20 LRU 알고리즘.png]]
    - **페이지 부재** : 12회
    - **페이지 교환** : 9회
    
    1. **카운터에 의한 방법**
        - 어떤 페이지에 대한 참조가 있을 때마다 그 시간 레지스터의 내용은 페이지 테이블 내에 있는 사용 시간 필드에 복사
        - 새로운 페이지가 호출되면 각 페이지 테이블 항목과 연관된 사용 시간 레지스터 값을 탐색하여 가장 작은 값을 가진 페이지를 교체
	2. **스택에 의한 방법**
	    - 스택에 페이지 번호를 수록하여 어떤 페이지가 호출될 때마다 스택의 꼭대기로 이동
	    - 스택의 꼭대기에 있는 페이지가 가장 최근에 사용된 것
	    - 바닥에 있는 것이 가장 오랫동안 사용되지 않은 것
4. **2차 기회 알고리즘**
    - 페이지 테이블의 각 항목에 한 개의 참조 비트를 연관시킨 후, 처음에 운영체제에 의해 모든 참조 비트는 0으로 설정
    - 프로세스가 수행되면서 참조한 각 페이지와 관계된 비트는 값이 1로 바뀜
    **주기억장치가 새로운 페이지로 교체되어야 할 경우 실행 단계**
    1. 페이지의 참조 비트를 조사하여 그 값이 0이면 그 페이지를 교체
    2. 참조 비트가 1이면 그 페이지에게 2차 기회를 주고 다음 페이지를 조사하기 위하여 FIFO 방식으로 진행
    ![[pg.154 그림 4-21 2차 기회 알고리즘.png]]
5. **LFU(Least Frequently Used) 알고리즘**
    - 가장 적게 사용되거나 집중적이 아닌 페이지가 교체됨
6. **MFU(Most Frequently Used)**
    - 가장 적은 참조 횟수를 가진 페이지가 가장 최근에 참고된 것이고 앞으로 사용될 것이라고 판단하는 알고리즘
7. **NUR(Not Used Recently)**
    - LRU와 유사한 알고리즘으로 최근에 사용되지 않는 페이지를 교체