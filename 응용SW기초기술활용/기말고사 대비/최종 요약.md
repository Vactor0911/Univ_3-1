# 5장
---
#### 디스크
---
**구조**
- **섹터** : 부채꼴 모양으로 나누어진 구역
- **트랙** : 중심축에 대해 동심원으로 나누어진 것
- **블록** : 섹터와 트랙의 교차점으로 둘러싸인 각각의 구역
- **실린더** : 헤드가 한 번에 판독,기록할 수 있는 트랙 군

**접근 구성 단계**
- **탐색 시간** : 실제 원하는 실린더를 찾는 데 소요되는 시간
- **회전 지연 시간** : 처리할 데이터가 있는 위치까지 오는 시간
- **전송 시간** : 읽은 데이터를 주기억장치에 전달하는 데 소요되는 시간
- **디스크 접근 시간** = 탐색 시간 + 회전 지연 시간 + 전송 시간

#### CD-ROM 방식
---
1. **등각 속도 방식**
	- 안쪽과 바깥쪽이 동일한 각도만큼 이동
	- 바깥쪽에서 읽을 때 데이터 전송이 빠름
	- 하드디스크나 플로피디스크가 사용하는 방식
2. **등선 속도 방식**
	- 회전 속도가 조절되어 읽고 쓰는 속도가 일정
	- 바깥쪽에서 읽을 때 느리게 회전
	- 데이터가 나선형 트랙을 따라 저장됨
	- 저장 용량이 크지만 데이터 접근 시간이 느림
	- 오디오, 비디오 광학 저장장치에 사용되는 방식

#### 파일 시스템 #중요 
---
- 파일을 저장하고 불러오기 위해 구축한 시스템
- 각종 정보를 논리적 저장 단위인 파일로 추상화하여 실제 기억장치 상에 맵핑

**구성**
1. 관련된 정보를 포함하는 실제적인 파일의 집합체
2. 모든 파일에 대한 정보를 제공하는 디렉터리 구조

**기능**
1. 생성, 수정, 삭제 가능
2. 적절한 제어 방법 제공
3. 여러 가지 접근 제어 방법 제공
4. 파일 구성
5. 백업과 복구
6. 기호화된 이름을 사용하여 파일 참조
7. 정보의 암호화와 복호화
8. 친숙한 인터페이스 제공

**예시** : FAT, NTFS, UFS, Ext, GFS, HDFS

**포맷(Format)** : 파일을 편하게 읽고 쓰기 위해 하나의 디스크를 여러 개의 섹터로 나누어 인덱스를 매기는 행위

#### 파일 #중요 
---
**구성 방식**
1. **순차 파일** : 논리적인 레코드를 물리적인 순서에 따라 순차적으로 저장하고 검색하도록 저장
	- 다음 레코드는 현 레코드의 바로 뒤에 저장
	- 순차적 특성을 갖는 기억 매체에 파일을 저장할 때 사용
	**장점** : 다음 레코드에 빠른 접근이 가능
	**단점** : 순차 파일에 대한 접근 방식이 파일에 저장된 레코드 순서와 다를 때 프로그램의 접근 속도 저하
2. **직접 파일** : 레코드가 직접 접근 기억장치의 물리적 주소를 통해 직접 접근
	- 특정 레코드를 검색하기 위해서는 사상 함수가 필요
	**장점** : 다른 레코드에 영향을 주지 않고 특정 레코드의 검색, 삽입, 수정, 삭제가 쉬움
	**단점** : 키 값의 순서에 의한 순차 검색이 어려움
3. **색인된 순차 파일** : 순차 파일과 직접 파일을 결합한 형태
	- 순차 및 직접 접근 모두 처리 가능
	- 레코드는 각 레코드의 키 값에 따라 논리적 순으로 배열
	**장점** : 파일 구조가 융통성이 많고 검색 성능도 우수
	**단점** : 설계 시 고려할 사항이 많음

**공간 할당** : 파일을 저장할 때 어떻게 할당하고, 효율적으로 공간을 이용할 수 있으며 얼마나 빠르게 접근할 수 있도록 할 것인지 결정하는 것
1. **연속 할당** : 파일들이 연속적으로 인접한 공간에 할당되는 것
	**장점** : 디스크 전체에 분산되어 있는 시스템보다 빠른 접근이 가능
	**단점**
		1. 생성시 필요한 공간 크기 명시 필요
		2. 기억 공간이 확보되지 않으면 파일 생성 불가
		3. 단편화 문제 발생
		4. 주기적인 집약이 필요
2. **불연속 할당**
	1. **연결 리스트** : 동일 파일에 속해 있는 섹터들이 연결 리스트의 형태로 디스크 전체에 분산
		- 디렉터리에는 파일의 시작 주소 및 마지막 주소에 대한 포인터가 존재
		**문제점**
			1. 검색에 긴 시간이 요구됨
			2. 연결 리스트 구조를 유지하는데 시간이 추가적으로 요구됨
			3. 포인터로 인해 가용 공간이 감소됨
	2. **색인 블록** : 각 파일마다 하나의 색인 블록을 두고, 산재해 있는 주소에 대한 포인터를 모아서 저장
		- 단편화 문제 없이 해당 블록에 대한 직접 접근이 가능
		**문제점** : 연결 리스트 방법보다 기억 장소의 낭비를 더 초래할 수 있음

#### 보호
---
- 물리적인 손상으로부터의 보호와 파일에서의 부당한 접근으로부터의 보호를 통칭

**기법**
1. **파일 이름** : 자신이 이름을 부여한 파일이 아니거나, 공유가 허용되었어도 다른 사용자의 파일을 알지 못하는 경우 접근을 불허
2. **암호** : 각 사용자마자 다른 암호를 제공하여 그 암호를 알아야만 파일 이용 가능
	**장점** : 보호 목적으로 작은 노력과 기억 장소가 소요됨
	**단점** : 파일의 보호가 불확실하며 암호가 쉽게 노출될 수 있고, 불법 사용자가 바뀐 암호를 이용할 수 있음
3. **접근 제어** : 사용자에 따라 접근이 가능한 유형을 다르게 명시
	- 각 파일이나 디렉터리에 명시된 접근 가능한 사용자와 가능한 동작을 운영체제가 참조하여 접근 여부를 결정
	- UNIX 시스템의 경우 `r (Read)`, `w (Write)`, `x (Execute)`의 접근 유형이 존재

#### 디렉터리 구조 #중요 
---
- 파일 시스템 내부에 있는 많은 파일들을 조직화하는 메커니즘

**기능**
1. **탐색** : 특정 파일에 대한 항목을 발견하기 위해 디렉터리를 찾는 기능
2. **파일 생성** : 새로운 파일들을 생성해야 할 때 디렉터리에 추가하는 기능
3. **파일 삭제** : 파일이 더 이상 필요하지 않을 때 디렉터리에서 삭제하는 기능
4. **디렉터리 리스트** : 디렉터리의 내용을 보여줄 수 있어야 하고, 각 파일에 대한 디렉터리 항목의 내용을 보여줄 수 있어야 하는 기능
5. **백업** : 만일을 대비해 파일들을 복사하여 저장하는 기능

**구조**
1. **일단계 구조 디렉터리** : 모든 파일이 같은 디렉터리 내에 위치
2. **이단계 구조 디렉터리** : 사용자 파일 디렉터리와 마스터 파일 디렉터리로 구성
	- 마스터 파일 디렉터리에는 사용자의 이름이 저장되어 있고, 각 항목은 사용자 디렉터리를 가리킴
3. **트리 구조 디렉터리** : 사용자들이 자신의 서브 디렉터리들을 생성하게 하고 그것에 따라 자신의 파일을 구성하도록 하는 것
	- 트리는 루트 디렉터리를 가지고 시스템 내의 모든 파일들은 유일한 경로 이름을 가짐
4. **비순환 구조 디렉터리** : 트리 구조로 된 디렉터리 시스템 중 가장 일반적인 방법
	- 파일 삭제 시 공유 파일에 할당된 기억 장소가 언제 해제되며 재사용할 수 있는가에 대한 문제 발생
5. **일반적 그래프 구조 디렉터리** : 트리 구조의 디렉터리에 링크를 첨가시킨 일반적 그래프 구조를 디렉터리 시스템에 적용한 방법
	- 무한 순환이 가능하므로 전역 탐색에는 신중해야 함
	- 각 디렉터리마다 불필요한 파일의 제거를 위한 가비지 컬렉션을 수행

# 6장
---
#중요 
**IPC** : 프로세스들 사이에서 서로 데이터를 주고 받는 행위
**공유 메모리** : 통신하는 프로세스들 사이에 특정 변수를 공유하여 정보를 교환하는 방법
**D-Bus** : 같은 머신에서 동시에 실행 중인 여러 컴퓨터 프로그램 간의 통신이 가능하도록 지원해주는 소프트웨어 버스
**모니터** : 순차적으로만 사용할 수 있는 특정 공유 자원이나 공유 자원 그룹을 할당하는 데 사용하는 병행성 구조
**동기화** : 특정한 순간에 특정한 프로세스를 독점하여 사용하는 것; `상호 배제 현상`

#### 임계 구역 #중요 
---
- 둘 이상의 프로세스가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부
- 어떤 프로세스가 공유 자원을 접근하는 동안 그 프로세스가 **임계 구역**에 있다고 함
- 임계 구역에 접근한 프로세스는 상호 배제를 보장 받아야 함
- 가능한 빨리 수행되어야 함
- 프로세스가 임계 구역에 들어간 후 블록 상태가 되지 않아야 함
- 무한 루프 상태가 되지 않아야 함

#### 상호 배제 #중요 
---
- 여러 프로세스들이 하나의 공유 자원을 상호 배타적으로 사용할 수 있으나, 동시에 사용할 수 없도록 하는 것

**조건**
1. **상호 배제** : 한 프로세스가 임계 구역에서 실행되고 있다면 다른 프로세스는 그 임계 구역에 들어갈 수 없다
2. **진행** : 임계 구역에서 실행 중인 프로세스가 없을 때 그 임계 구역으로 진입하려는 프로세스가 있을 경우, 임계 구역이 아닌 곳에서 실행 중인 프로세스들만 임계 구역으로의 진입을 결정하는데 참여할 수 있으며, 이 선택은 무한 연기되어서는 안 된다.
3. **한정된 대기**: 어떤 프로세스가 임계 구역에 진입을 요청한 이후부터 그 요청이 허용될 때까지 다른 프로세스들의 임계 구역 진입 허용 횟수에 한계가 있어야 한다는 것으로, 이 한계를 통해 임의의 프로세스의 기아를 예방할 수 있다.

**알고리즘**
1. **1단계 알고리즘** : 한순간에 하나의 프로세스만이 임계 구역에 진입하도록 허용함
	- `turn` 변수를 사용
	- 프로세스들이 임계 구역을 교대로 수행하도록 되어 있기 때문에 **진행** 조건이 충족되지 않음
2. **2단계 알고리즘** : 프로세스의 상태에 관한 정보를 유지하기 위하여 turn 변수를 배열로 변경
	- `flag[2] 배열을 사용`
	- **진행** 조건이 충족되지 않음
3. **3단계 알고리즘**
	- `flag[2]` 와 `turn` 변수를 공유
	- `flag[i]` 와 `flag[j]` 모두 `true`인 경우 `turn` 값에 따라 임계 구역에 진입할 프로세스를 결정
	- 3가지 조건을 모두 충족
	- Peterson 알고리즘이라고도 함
4. **Dekker 알고리즘**
	- `flag[2]` 와 `turn` 변수를 공유
	- 3가지 조건을 모두 충족
	- 3단계에선 "I enter" 라고 하지만, Dekker에선 "You may enter" 라고 함
5. **Bakery 알고리즘**
	- 3가지 조건을 모두 충족

#### 하드웨어에 의한 동기화
---
- 공유 변수가 변경되는 동안 인터럽트 발생을 허용하지 않도록 설정하여 단일 프로세서 시스템에서 임계 구역 문제 해결함

#### 세마포어 #중요 
---
- 동시 접근을 막아 상호 배제 현상을 보장하기 위해 사용하는 변수 체계를 통칭하는 것
- `P`와 `V` 연산시 세마포어의 정수 값을 변경하는 연산은 원자적으로 분리되지 않는 연산으로 수행

#### 메시지
---
- 송신측 프로세스와 수신측 프로세스 간에 교환될 수 있는 정보의 집합

# 7장
---
**무한 연기** : 한 프로세스가 시스템에 의해 처리되는 동안 다른 프로세스의 스케줄링은 끝없이 연기될 가능성의 상태

#### 교착 상태 #중요 
---
- 특정 프로세스가 특정한 자원을 사용하기 위하여 무한정 기다려도 도저히 해결할 수 없는 상태

#### 교착 상태 조건 #중요 
---
1. **상호 배제** : 프로세스들은 자원에 대해 배타적인 사용을 요구
2. **점유와 대기** : 어떤 프로세스가 자원을 점유하면서 다른 프로세스에 의해 점유된 자원을 요구하고 할당 받기를 기다림
3. **비선점** : 자원을 점유하고 있는 프로세스는 그 작업의 수행이 끝날 때까지 해당 자원을 반환하지 않음
4. **환형 대기** : 프로세스들의 환형 대기를 구성하는 각 프로세스는 환형 내의 이전 프로세스가 요청하는 자원을 점유하고 다음 프로세스가 점유하고 있는 자원을 요청

#### 교착 상태 예방 #중요 
---
- 사전에 교착 상태 발생 가능성을 제거한다는 것으로, `하벤더`가 제시
- 교착 상태의 네 가지 조건 중 어느 하나의 조건 만이라도 만족하지 않으면 교착 상태가 발생될 수 없다는 이론
- 첫 번째 조건인 `상호 배제 조건`은 배타적 사용을 보장하기 위해 부정하지 않음

1. **점유와 대기 조건 방지**
	- 각 프로세스는 필요한 자원들을 한번에 모두 신청
	- 프로세스가 요구한 자원을 전부 할당하거나 또는 하나라도 부족하면 전혀 할당하지 않는 방식
2. **비선점 조건 방지**
	- 프로세스의 추가 자원에 대한 요구가 거절 당했다면 자원을 전부 반납하고 필요하다면 추가 자원과 함께 다시 요구하도록 하는 방식
	- 사용되고 있는 자원을 반환하므로 그 시점까지 실행한 중간 결과를 포기하여야 하는 경우가 발생하여 비용이 증가
3. **환형 대기 조건 방지**
	- 모든 자원에게 고유 번호를 부여하여 현재 가지고 있는 자원보다 더 큰 번호를 가진 자원만 요청하도록 제한하는 방법

#### 교착 상태 회복 방법
---
- 교착 상태가 발생하면 하나 또는 그 이상의 필요 조건을 제거하여 복구
- 한 개 또는 그 이상의 프로세스를 희생시켜 선점을 허용

- **희생자(victim) 선정** : 어떤 프로세스를 희생시킬 것인가를 결정
	**기준**
	1. 프로세스들의 우선순위
	2. 프로세스가 연산했던 시간과 일을 완료하기 위해 요구되는 시간
	3. 프로세스가 사용하고 있는 자원의 유형과 수
	4. 희생시킬 프로세스의 수
- **복귀 문제** : 어느 정도의 시간(범위)을 복귀시켜야 하는가 하는 기간의 결정
	- 가장 간단한 방법 : 처음부터 다시 시작하는 방법
	- 효과적인 방법 : **교착 상태를 해소할 수 있는 최소한의 프로세스를 최소한의 시간 범위 안에서 복귀시키는 방법**이나, 현재 수행되고 있는 모든 프로세스의 상태 정보가 요구됨
- **기아 현상 문제** : 희생되어야 할 프로세스를 비용의 감소에만 국한하여 선정할 경우 어느 한 프로세스가 반복적으로 희생자로 선정될 수 있는 가능성이 있다는 것
	- 비용을 고려하여 희생자를 선정하더라도 반복하여 선정될 그 반복 횟수의 상한선을 결정하고, 그 값에 도달하면 그 프로세스는 더 이상 희생자가 될 수 없도록 하여 해결 가능
#### 교착 상태 회피 #중요 
---
- 교착 상태의 네 가지 조건 중 하나를 제거하지는 못하더라도 실행 프로세스의 자원 요구 순서를 알 수 있다면 교착 상태를 회피 가능

**은행가 알고리즘** : 안전 상태의 개념을 이용하여 불안전 상태나 교착 상태를 피할 수 있는 자원 할당 알고리즘
- **안전 상태** : 전체 자원의 상황이 모든 사용자가 작업을 완료할 수 있는 상태
- **불안전 상태** : 교착 상태가 일어날 수 있는 상태

**단점**
- 남아 있는 자원의 수를 파악하기 어려움
- 모든 요청에 대해 주어진 시간 내에서 자원을 할당할 수 있도록 더 강력한 보장이 필요
- 최대 요구량을 파악하기 어려움
- 사용자는 무슨 자원이 얼마나 필요한지 알기 어려움

# 8장
---
#중요 
**보안** : 시스템과 그 시스템의 자료들이 결함 없이 보전된다는 것을 의미하는 일종의 신뢰도
**보호** : 컴퓨터 시스템에 정의된 자원에 대하여 프로그램, 프로세스, 또는 사용자의 접근을 제어하는 기법
**정책** : 무엇을 수행할 것인가를 결정하는 것
**기법** : 어떻게 수행할 것인가를 결정하는 일

#### 보안 위협 #중요 
---
1. **흐름 차단** : 시스템의 일부가 파괴되거나 사용할 수 없게 된 상태
	- 가용성에 대한 위협
2. **가로채기** : 인가 받지 않은 제3자가 컴퓨터 자원을 접근하는 경우
	- 비밀성에 관한 위협
3. **변조** : 인가 받지 않는 제3자가 자원에 접근할 뿐만 아니라 내용을 고치기까지 하는 경우
	- 무결성에 대한 위협
4. **위조** : 인가 받지 않은 제3자가 시스템에 위조물을 삽입하는 경우
	- 무결성에 대한 위협

- **적극적인 공격** : 시스템의 자원들을 의도적으로 변화시키거나 시스템 운영에 영향을 주려는 시도
    
- **소극적인 공격** : 시스템의 정보를 알아내거나 악용하려고 시도는 하지만 시스템 자원에 직접적인 영향을 주지는 않는 것

#### 보안 요구사항 #중요 
---
1. **비밀성 (기밀성)** : 컴퓨터 시스템 내의 정보는 인가 받은 사용자만이 접근할 수 있도록 보장하는 것
2. **무결성** : 컴퓨터 시스템 내의 정보 및 유통 정보에 대하여 인가 받은 사용자만이 수정할 수 있도록 보장하는 것
3. **가용성** : 인가된 시스템 실체의 요구 시 접근 및 사용될 수 있는 시스템 또는 시스템 자원의 자산
4. **인증** : 컴퓨터에 접근하기 위한 첫 단계로 일반적으로 사용자 식별자를 제공하고 이에 대한 정당성을 주장하는 패스워드의 입력을 통하여 증명하는 것
5. **부인봉쇄** : 송신자나 수신자가 전송된 메시지를 부인하지 못하도록 방어하는 것

#### 보안 기법
---
1. **대칭키 암호방식**
	- 자료를 특정한 키로 암호화하고 동일한 키를 소유하지 못한 제3자는 암호화된 자료를 획득한다고 해도 해독이 어렵도록 변환시키는 방식
	- 송신자와 수신자는 동일한 비밀 키를 공유하고 있어야 하며, 제3자가 알 수 없도록 해야함
2. **비대칭키 암호방식**
	- 두 개의 키가 각각 암호화 및 복호화 과정에 사용됨
	- 두 개의 키 중에 하나는 공개되어 있는 공개 키이고, 다른 하나는 개인이 비밀 보관하는 개인 키

# 9장
---
#### 병렬성 #중요 
---
1. **작업 단계** : 각각의 프로그램을 작업이라 할 때, 필요한 자료가 각각 준비되어 있을 경우 두 작업은 병렬로 처리
2. **태스크 단계** : 전체 프로그램이 여러 개의 태스크로 분할될 수 있는 하나의 작업일 때, 여러 태스크는  상호 작용이 필요하다 해도 병렬로 수행
3. **프로세스 단계** : 태스크는 여러 개의 프로세스로 분할되고, 각 프로세스는 특정한 기능을 수행하는 하나의 개체
4. **변수 단계** : 다수의 변수들이 동시에 연산 가능
5. **비트 단계** : 병렬성이 존재할 수 있는 최저 단계

#### 운영체제 구성 #중요 
---
1. **주/종 관계** : 가장 구현하기 쉬운 다중 처리 시스템의 형태
	- 주 프로세서만이 운영체제를 실행하고 종속 프로세서는 사용자 프로그램만 실행
	- 종 프로세서가 주 프로세서의 서비스를 받아야 할 때, 주 프로세서에게 서비스에 대한 요구를 해야 하고 주 프로세서가 이 인터럽트를 처리
	- 제어 테이블 등에 대한 상호 배제가 비교적 쉬움
2. **독립 수행** : 각 프로세서가 자신의 운영체제를 가짐
	- 각 프로세서에서 발생하는 인터럽트는 해당 프로세서가 해결
	- 운영체제의 기능도 각 프로세서에서 독자적으로 수행되고 전체 시스템에 대한 총괄적인 정보 접근은 상호 배제적인 기술을 이용하여 신중히 제어
	- 각 프로세서에 속하는 프로세스는 서로 협동하지 않음
3. **대칭적 처리** : 모든 프로세서가 동등한 입장의 대칭성을 가지는 형태
	- 작업 부하에 대한 균형
	- 여러 프로세서들이 동시에 운영체제를 수행할 수 있으므로 재진입코드와 상호 배제가 필요
	- 가장 신뢰성이 높음
	- 동일한 프로세서들의 저장 장소를 운영

#### Flynn의 분류 #중요 
---
- **파이프라이닝** : 하나의 명령어가 실행되는 도중에 다른 명령어를 실행하는 방식으로 동시에 여러 개의 명령어를 실행하는 기법

1. **SISD** : 한 번에 한 개씩의 명령어와 데이터를 처리하는 단일 프로세서 시스템
	- 파이프라이닝으로 구성
2. **SIMD** : 여러 개의 프로세서들로 구성되고, 프로세서들의 동작은 모두 하나의 제어장치에 의해 제어
	- 배열 프로세서와 파이프라인을 이용
	- 모든 프로세서들은 제어장치로부터 동일한 명령어를 받지만 명령어 실행 과정에서 서로 다른 데이터들을 사용
3. **MISD** : 여러 개의 제어 장치와 프로세서를 갖는 구조
	- 각 프로세서들은 서로 다른 명령어들을 실행하지만 처리하는 데이터는 하나의 스트림
	- 파이프라인에 의한 비동기적 병렬 처리가 가능
4. **MIMD** : 여러 개의 프로세서들이 서로 다른 명령어와 데이터를 처리
	- **밀착된 결합 시스템** : 모든 프로세서가 기억장치를 공유하는 공유 기억장치 구조
	- **느슨한 결합 시스템** : 각 프로세서가 자신의 지역 메모리를 가진 독립적인 컴퓨터들로 구성

# 10장
---
#### 분산 처리 시스템
---
- 데이터 처리 장치 및 데이터베이스가 지역적으로 분산되어 있으면서 정보교환을 위하여 네트워크로 상호 결합된 시스템

**장점**
1. 중앙 집중 방식의 대형 컴퓨터에서 처리되는 것보다 경제적
2. 중요한 데이터의 중복을 통하여 높은 신뢰성 및 가용성
3. 통신 경비 및 부하 감소
4. 기존의 시스템에 영향을 미치지 않고 쉽게 시스템의 확장 및 재구성 가능
5. 고도의 응답성으로 시스템 성능 향상

**형태**
1. **밀착된 결합 시스템**
	- 프로세서들이 기억장치와 클럭을 공유
	- 다중 프로세서 간의 통신은 보통 공유 메모리를 통해 수행
2. **느슨한 결합**
	- 프로세서들이 기억장치와 클럭을 공유하지 않음
	- 각 프로세서들은 자신의 지역 기억장치를 가짐
	- 프로세서들은 고속의 버스나 전화선과 같은 다양한 통신 회선을 통해 서로 통신

#### 위상에 따른 구분
---
1. **완전 연결 구조 (메쉬형)**
	- 각 노드가 시스템 내의 모든 다른 노드와 직접 연결
	- 특정 두 노드만을 연결하는 하나의 회선을 사용하는 형식
	- 신뢰성이 매우 높음
2. **부분 연결 구조**
	- 기본 비용은 완전 연결 네트워크보다 적음
	- 메시지는 여러 중간 노드를 거쳐서 전송될 수 있으므로 통신 속도가 늦음
	- 한 회선의 고장으로 네트워크가 분할될 수도 있기 때문에 신뢰성이 떨어짐
3. **계층 구조**
	- 각 사이트들은 트리 형태로 구성
	- 형제 중의 하나가 다른 형제에게 메시지를 전달하려면 부모까지 올라가야 함
	- 부모 사이트에서 고장이 발생했다면, 그 사이트의 자식들은 더 이상 다른 프로세서들과 통신할 수 없음
4. **성형 구조 (star형)**
	- 중심 노드가 다른 모든 노드와 완전 연결
	- 중심을 제외한 노드들은 모두 서로와 연결되어 있지 않음
	- 중심 노드는 메시지 교환 작업만을 담당
5. **환형 구조 (ring형)**
	- **단방향 구조** : 모든 노드는 같은 방향으로만 정보를 전달 가능
	- **양방향 구조** : 한 노드는 양쪽 이웃 모두에게 정보를 전달
6. **다중 접근 버스 구조**
	- 공유되는 하나의 버스가 존재
	- 네트워크의 기본비용은 노드 수에 비례
7. **혼성 네트워크 (hybrid)**
	- 서로 다른 유형의 네트워크들이 상호 연결되어 있는 형태
	- 통신은 상호 간에 다중 프로토콜을 번역해야 하고, 데이터에 대한 경로 배정이 복잡

#### 분산 범위에 따른 분류
---
1. **광역 네트워크**
	- 넓은 지역에 걸쳐 광범위하게 위치하는 자율성을 가지는 많은 수의 프로세서들로 구성
	- 인터넷 광역 네트워크는 지역적으로 분리된 사이트들에 있는 호스트들 간에 서로 통신할 수 있는 기능을 제공
2. **근거리 네트워크**
	- 한 빌딩 또는 몇 개의 인접된 빌딩과 같은 비교적 가까운 지역에 적용되도록 설계
	- 모든 사이트는 서로 근접해 있기 때문에 통신 링크는 일반적인 컴퓨터 네트워크보다 속도가 빠르고, 오류 발생률이 낮음

#### 운영체제 구분
---
1. **네트워크 운영체제** : 기종의 차이가 심하고 지역적으로 널리 분산되어 있는 대규모 네트워크 시스템에서 주로 사용
	- 각 노드는 다른 노드와는 무관한 독자적인 운영체제를 갖고 수행
	- 필요한 경우만 가끔씩 네트워크를 통해 다른 노드와 통신
	- 각 노드의 운영체제는 네트워크와는 관계가 없으며 네트워크의 사용은 각 노드에서 실행되고 있는 사용자 프로그램에 의해서 제어
2. **분산 운영체제** : 미니 혹은 마이크로컴퓨터들의 근거리 네트워크에서 많이 사용
	- 분산된 시스템 내에 하나의 운영체제가 존재
	- 네트워크의 이해, 유지, 수정 등이 용이
	- 시스템 내의 자원들을 광역적으로 봄

#### 클라우드 컴퓨팅 #중요 
---
- 인터넷을 이용한 IT 자원의 주문형 아웃소싱 서비스
- 사용자들은 필요한 IT 자원을 원하는 시점에 원하는 만큼 골라 사용하게 되고, 사용량을 기반으로 대가를 지불

**특징**
1. 사용의 용이성
2. 접근성
3. 다중 역할
4. 사용자 수준에서 보안과 유연성

**장점**
1. 신뢰성이 높음
2. 초기 투자비용 감소
3. 전력 소비 절약
4. 비즈니스 민첩성, 내부 협업 및 비즈니스 파트너나 다른 이해 관계자들과의 협업이 수월

**단점**
1. 민감하거나 취약한 정보가 해킹이나 유출되는 경우, 개인, 조직 또는 국가에 큰 위험이 발생
2. 자연 재해와 외부 공격을 막지 못할 경우 막대한 피해가 발생
3. 인터넷이 작동하지 않거나 네트워크 연결이 느려 진다면 온라인 작업이 불가능

**그리드 컴퓨팅** : 하나로 처리하기 힘든 작업을 여러 대의 컴퓨터로 나누어 처리하는 기술
- 복잡한 계산을 쉽게 할 수 있는 슈퍼컴퓨터의 용량을 갖는 가상 컴퓨팅
- 하나의 문제가 많은 컴퓨터로 처리되어 신속하고 효율적으로 해결

**유틸리티 컴퓨팅** : 고객은 개인 서비스 제공자에 의해 설계된 유틸리티 컴퓨팅 시스템을 사용
- 구조 및 구성 요소는 고객의 요구 사항에 맞게 설계
- 지불 방식이 클라우드 컴퓨팅과 유사

**종류**
1. **개인형 클라우드 컴퓨팅**
	- 기업 내에 클라우드 데이터 센터를 운영
	- 강화된 보안, 안정성 및 기업 소유권 보장 등의 많은 혜택
	- 조직 내의 데이터 및 응용 프로그램은 보안 연결이 요구
2. **공공형 클라우드 컴퓨팅**
	- 서비스 제공자는 사용자에게 상업적인 엔티티로 클라우드 인프라를 제공
	- 훨씬 저렴한 비용으로 서비스 및 응용 프로그램을 만들거나 사용 가능
3. **혼합형 클라우드 컴퓨팅**
	- 개인형과 공공형 클라우드 컴퓨팅의 기능이 조합

**클라우드 서비스 모델**
- **IaaS (Infrastructure as a Service)** : 확장성이 높고 자동화된 컴퓨팅 리소스를 가상화하여 제공
- **Paas (Platform as a Service)** : 사용자 정의 응용 프로그램을 개발하고 사용할 수 있는 개발자를 위한 프레임워크를 제공
	미들웨어에서 제공하는 API를 사용하여 소프트웨어를 개발 가능
- **SaaS (Software as a Service)** : 사용자에게 제공되는 소프트웨어를 가상화하여 제공

# 11장
---
#### 가상 기계 #중요 
---
- 컴퓨팅 환경을 소프트웨어로 구현한 것으로, 컴퓨터를 에뮬레이트하는 소프트웨어를 뜻함

**구조**
- 기본 호스트 시스템의 하드웨어 자원을 사용하는 자체 운영체제가 있고, 게스트 시스템은 RAM, 하드디스크 공간 및 파일 시스템을 갖춘 독립된 컴퓨터처럼 작동
- 가상기계 모니터라 부르는 하이퍼바이저 소프트웨어를 기반

**장점**
1. 다수의 게스트 시스템을 병렬로 운영
2. 하드웨어를 통합하여 하드웨어 사용률 향상
3. 게스트 시스템 및 해당 시스템 내에서 실행 중인 모든 프로세스의 강력한 캡슐화
4. IT 자원 유지 관리 및 관리 비용 절감
5. 가상 서버 및 개인용 컴퓨터의 유연한 배치 및 이식

**단점**
1. 하이퍼바이저 및 게스트 시스템의 오버헤드
2. 공유된 하드웨어가 파워 피크 되었을 때 병목 현상이 발생
3. 단일 장애 지점인 하이퍼바이저
4. 장애가 발생되었을 경우 장애 원인을 찾는데 시간이 오래 걸림

**하이퍼바이저** : 호스트 시스템에서 다수의 게스트 운영체제를 구동할 수 있게 하는 소프트웨어
- 하드웨어를 가상화하면서 하드웨어와 각각의 기상기계를 모니터링 하는 중간 관리자 역할

#### 가상화 #중요 
---
1. **호스트 가상화** : 기초가 되는 호스트 운영체제 위에 게스트 운영체제가 구동되는 방식
	- **장점** : 호스트 운영체제에 크게 제약사항이 없음
	- **단점** : 오버헤드가 클 수 있음
2. **하이퍼바이저 가상화** : 호스트 운영체제 없이 하드웨어에 하이퍼바이저를 설치하여 사용하는 방식
	- **장점** : 오버헤드가 적고, 효율적으로 자원을 사용할 수 있음
	- **단점** : 관리를 위한 컴퓨터나 콘솔이 필요함
3. **전가상화** : 하드웨어를 완전히 가상화 하는 방식
	- 중간의 하이퍼바이저를 통과하며 직접적인 하드웨어 접근이 불가능
	- **장점** : 게스트 운영체제의 수정이 필요 없음
	- **단점** : 성능이 비교적 느림
4. **반가상화** : 하드웨어를 완전히 가상화 하지 않고, 게스트 운영체제의 커널을 일부 수정해 하드웨어와 상호작용할 수 있도록 하는 방식
	- 직접 하드웨어에 접근이 가능
	- 하이퍼 콜이라는 인터페이스를 통해 하이퍼바이저에게 직접 요청
	- **장점** : 전가상화에 비해 성능이 빠름
	- **단점** : 각 운영체제의 커널을 수정해야 하고, 리소스 차지가 심함
5. **컨테이너 가상화** : 호스트 운영체제 위에 컨테이너 관리 소프트웨어를 설치하여, 논리적으로 컨테이너를 나누어 사용하는 방식
	- 각각 개별 서버처럼 사용이 가능
	- **장점** : 오버헤드가 적어 가볍고 빠름

#### 임베디드 시스템
---
- `마이크로프로세서` 혹은 `마이크로컨트롤러`를 내장하여 시스템 제작자가 의도한 몇 가지 혹은 특수한 기능만을 수행하도록 제작된 장치
- `내장형 시스템` 또는 `특정 목적을 수행하는 시스템`

**명령어 방식에 따른 분류**
1. **RISC**
	- 명령어의 수가 상대적으로 적어 구조가 단순함
	- 단순한 명령의 처리에 있어 성능이 우수
	- 시스템의 규모가 작고, 저전력 사용
	- 소형이고 저렴한 휴대용 단말기에 적합
2. **CISC**
	- 하드웨어에서 명령어를 처리하여 하드웨어 자체가 크고 복잡
	- 시스템의 규모가 크고 전력 소모가 큼
	- 대량의 데이터 처리에 효과적이지만 가격이 비쌈

#### IoT 운영체제
---
- 다양한 물리적 장치에 센서, 소프트웨어 등 기술을 통해 인터넷에 연결하여 데이터를 수집하거나 공유하는 네트워크
- 메모리 크기, 전력 및 처리 용량에 대한 제한 등 IOT 장치와 관련된 제약 조건 내에서 수행하도록 설계