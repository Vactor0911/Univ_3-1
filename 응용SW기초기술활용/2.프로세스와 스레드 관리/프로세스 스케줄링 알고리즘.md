#중요 
#### 스케줄링 알고리즘의 평가 척도
- [[반환시간]]

#### FCFS(First Come First Served) 스케줄링
- 가장 간단한 스케줄링 방식
- 프로세스들은 대기 큐에 도착한 순서에 따라 CPU를 할당
- **비선점 스케줄링**

**평균 반환시간 및 평균 대기시간 계산 예시**
![[pg.65 FCFS 스케줄링 예시.png]]
**Gantt 차트**
![[pg.65 FCFS 스케줄링 Gantt 차트.png]]
- **평균 반환시간** : (21 + 24 + 30) / 3 = 25 > 호위 효과 발생[^1]
- **평균 대기시간** : (0 + 21 + 24) / 3 = 15

**프로세스 도착순서가 P2, P1, P3이라고 하면**
- **평균 반환시간** = (3 + 24 + 30) / 3 = 19
- **평균 대기시간** = (0 + 3 + 24) / 3 = 9

#### SJF(Shortest Job First) 스케줄링
- 기다리고 있는 프로세스 중에서 수행시간이 가장 짧은 것을 먼저 수행
- FCFS보다 평균 대기시간을 감소시키는 반면 큰 프로세스에 대해서는 대기시간의 분산이 크고 예측하기가 어려움
- 수행될 프로세스나 프로세스가 얼마나 긴 것인지 정확히 알아내기가 어렵다는 문제점이 있음
- **비선점 스케줄링**

**평균 반환시간 및 평균 대기시간 계산 예시**
![[pg.67 SJF 스케줄링 예시.png]]
- **평균 반환시간** : (3 + 9 + 16 + 24) / 4 = 13

#### 우선순위(Priority) 스케줄링
- 우선순위가 각 프로세스에게 주어지며, CPU는 가장 높은 우선순위를 가진 프로세스로 할당
- 우선순위가 같은 프로세스들은 FCFS 순서로 스케줄
- **선점 / 비선점 스케줄링**
- **주요 문제점** : 무한 대기 / 기아 현상
- **해결 책** : 에이징(aging)[^2]

**평균 반환시간 및 평균 대기시간 계산 예시**
![[pg.68 우선순위 스케줄링 예시.png]]
**Gantt 차트**
![[pg.68 우선순위 스케줄링 Gantt 차트.png]]
- **평균 반환시간** : (9 + 11 + 1 + 13 + 19) / 5 = 10.6
- **평균 대기시간** : (1 + 9 + 0 + 11 + 13) / 5 = 6.8

#### 라운드 로빈(Round-Robin) 스케줄링
- 시분할 시스템을 위하여 고안된  방식
- 각 프로세스는 같은 크기의 CPU 시간을 할당 받음
- 대화식 사용자들에게 알맞은 응답시간을 보장해 주어야 하는 시분할 방식의 시스템에서 효과적
- **선점 스케줄링**

![[pg.69 그림 2-7 라운드 로빈 스케줄링.png]]
- 할당 시간의 크기는 컴퓨터 시스템의 효과적인 동작에 절대적인 영향을 미침
	- 할당 시간이 너무 크면, 라운드 로빈 방법은 FCFS 방식과 같은 형식이 됨
	- 할당 시간이 너무 적으면, 문맥 교환을 위한 오버헤드로 시스템의 성능이 저하
- **할당 시간에 따른 문맥 교환 횟수**
  ![[pg.71 그림 2-8 할당시간에 따른 문맥 교환 횟수.png]]

#### SRT(Shortest Remaining Time) 스케줄링
- SRT 혹은 Preemptive SJF 스케줄링 기법은 SJF 기법에 선점 방식을 도입한 방법으로서 시분할 시스템에서 유용
- 새로 도착한 프로세스를 포함하여 처리가 완료되는 데 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행
- **선점 스케줄링**

**평균 반환시간 및 평균 대기시간 계산 예시**
![[pg.72 SRT 스케줄링 예시.png]]
**Gantt 차트**
![[pg.72 SRT 스케줄링 Gantt 차트.png]]
- **평균 반환시간** : P1=(14-0)=14, P2=(9-1)=8, P3=(4-2)=2, P4=(6-3)=3이므로 (14+8+2+3)/4=6.75
- **평균 대기시간** : P1=0+(9-1)=8, P2=6-2=4, P3=0, P4=4-3=1이므로 (8+4+0+1) /4=3.25

#### 다단계 큐(Multilevel Queue) 스케줄링
- 다단계 큐 스케줄링 알고리즘은 준비 큐를 다수의 별개 큐로 나눔
- 기억장치의 요구량이나 프로세스의 우선순위 혹은 프로세스의 유형과 같은 프로세스의 특성에 근거해 프로세스들은 해당 큐에 할당됨
- 각 큐는 자신의 스케줄링 알고리즘을 갖고 있음

**5개의 큐를 가진 다단계 큐 스케줄링 알고리즘의 예**
![[pg.74 다단계 큐 스케줄링 알고리즘 예시.png]]

#### 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링
- 새로운 프로세스는 큐잉 네트워크의 일단계 큐의 뒤쪽에 들어감
- 그 프로세스는 CPU를 차지할 때까지 큐를 통하여 FCFS에 의하여 이동
- 만약 프로세스가 끝나기 전에 할당된 시간이 만료되었거나 입출력 혹은 어떤 돌발사건 등으로 인하여 CPU를 양도한다면 그 작업은 그 다음 하위 단계의 큐로 이동되어 재배치
- 마지막 단계의 큐에서는 그 프로세스가 완료될 때까지 라운드 로빈으로 순환
- 어떤 임의의 큐에 있는 프로세스는 모든 상위 단계의 큐가 비어 있지 않으면 수행될 수 없으며, 수행 중인 프로세스라도 더 높은 단계의 큐에 있는 프로세스에 의해 선점될 수 있음
- 다단계 피드백 큐 기법은 CPU에 대한 요구량에 따라 프로세스들을 분류하는 데 이상적

![[pg.76 그림 2-9 다단계 피드백 큐.png]]

#### HRRN(Highest Response Ratio Next) 스케줄링
- 한 작업이 중앙처리장치를 차지하면 그 작업은 완성될 때까지 실행하며, 대기시간이 고려되어 긴 작업과 짧은 작업 간의 불평등을 어느 정도 완화

**우선순위 계산식**
![[pg.78 HRRN 스케줄링 우선순위 계산식.png]]
- 시스템 응답시간 값이 클수록 우선순위가 높아짐
- 짧은 작업일 경우라도 대기시간이 큰 작업은 우선순위가 높아짐

**평균 반환시간 및 평균 대기시간 계산 예시**
![[pg.78  HRRN 스케줄링 예시.png]]
**Gantt 차트**
![[pg.78 HRRN 스케줄링 Gantt 차트.png]]



[^1]:**호위 효과(convoy effect)** : 먼저 도착한 프로세스가 끝날 때까지 매우 긴 시간을 기다리게 되는 것
[^2]: **에이징(aging)** : 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 방법